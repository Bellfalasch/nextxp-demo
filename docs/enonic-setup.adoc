= Setting up Enonic
:toc: right
:imagesdir: media/

In this chapter, we will build a custom app based on the HMDB project, and play around with the Headless API

TIP: For an in-depth introduction to Enonic, visit the official link:https://developer.enonic.com/guides/developer-101/xp7[Enonic Developer 101] guide.

[[xp-at-a-glance]]
== Enonic at a glance

Our platform is actually called Enonic XP (XP, or Enonic for short).

=== Enonic apps
Enonic XP allows you to install and run one or more link:https://developer.enonic.com/guides/developer-101/xp7/apps[**applications**] in a single instance.

You can discover ready to run applications on link:https://market.enonic.com/[Enonic Market], or you may build your own, like we will be doing in this tutorial.
Each app may provide specific functionality. It may for instance be everything you need for a large website, or provide only specific services, such as an **API**. An app is given an <<#new-project, **app name**>> when it's built.

Apps may provide a range of different functionality. For this tutorial we will focus on headless CMS capabilities.

TIP: Useful terminology: A **sandbox** is a local Enonic server running on your laptop. Apps are built from **projects** which are basically a folder that contains the app's source code. Once it is built, it can be **deployed** to the sandbox - where it will be started and made available.

For production use and CI/CD, Enonic apps may be installed in many different ways, typically using link:https://developer.enonic.com/docs/enonic-cli/master[enonic CLI]. In some cases, apps may even be installed directly via the Enonic link:https://developer.enonic.com/docs/xp/stable/admin#admin_console[Admin console].

[[xp-content]]
=== Content

Apps typically ship with one or more link:https://developer.enonic.com/guides/developer-101/xp7/content[**content types**]. Content types typically define data structures (similar to fields in classes in object-oriented languages). Each content type gets a unique name which is automatically pre-fixed with the app-name. e.g. `<appName>:<contentTypeName>`.

Content types are used to create **content items**. Content is commonly created and handled via Enonic's link:https://enonic.com/blog/publishing-power-enonic-content-studio-cheat-sheet[**Content Studio**]. Content may be organised in tree structures, which can be useful both for internal purposes, but also externally - as we will see in this tutorial.

All content items get a unique path **name** when creating it - this is similar to a filename - and a human-friendly displayName.

Content can exist on two different link:https://developer.enonic.com/docs/xp/stable/storage/branches[**branches**]: When creating or editing in Content Studio, you're always working on the `draft` branch. When publishing, new items and changes are copied to the `master` branch - which is often publicly accessible.

[[hmdb]]
== The Headless Movie Database

With Enonic, you may obviously create your own content model, but to save time, we'll be using a demo-app known as the link:https://market.enonic.com/vendors/enonic/headless-movie-db[Headless Movie Database] (HMDB) as our starting point.

HMDB ships with a pre-defined content-model and some useful sample content. It also exposes the content through a link:https://graphql.org/[graphQL] API. This API gives us access to the content.

Let's get going!

=== Task: Create application from template

. link:https://developer.enonic.com/start[**Install the Enonic CLI**] (follow link for instructions).

. **Create a new project** using the "Headless movie database" as your template:
+
Run the following command from your terminal
+
[source,bash]
----
enonic project create -r app-hmdb
----
+
NOTE: Stick with the standard values and keep the suggested project name `com.example.myproject` for the examples in the tutorial to work properly.
This will be referred to as **app name** later in this tutorial.
+
. **Deploy the application** locally:
+
[source,bash]
----
enonic project deploy
----
+
The application will now be built. When asked to start a sandbox (a local instance of XP running its own content storage area), hit _Yes_. Enonic starts, outputs some server logs, and the sample content is imported.
+
. **Install and test Content Studio**.
+
Navigate to http://localhost:8080 Select admin, and log in (you don't have to create a user for this tutorial).
+
Install **Content Studio** (it's an XP app of its own) by completing the _XP Tour_ , or via the Applications admin app.
+
From the _XP_ menu, open `Content Studio`, and choose the HMDB project if asked. You should see something like this:
+
image:hmdb-content.png[title="HMDB in Content Studio", width=600px]
+
NOTE: Some items have a default preview. That's okay for now - as we will customize this preview later.


[[queries]]
== Headless API

We'll take a quick look at GraphQL and how to use link:https://developer.enonic.com/docs/guillotine/stable[Guillotine API].

TIP: New to GraphQL? Check out the link:https://graphql.org/[GraphQL documentation]

### Task: Run a simple query

. **Access the guillotine API:**
+
Visit this link http://localhost:8080/site/hmdb/draft/hmdb/_graphql to access the Headless API, and the draft content items.
+
image:graphql-playground.png[title="The built-in API: GraphQL Playground", width=768px]
+
The interface served when we access the endpoint lets us browse the API directly. Use the tabs on the far right to discover. Use the left hand field to type/paste in queries, press the "play" button in the middle to **run the query**, and the result will be presented in the right hand field.
+
. **Query movies**:
+
One of the objectives in this tutorial is listing and presenting movie details. Run this simple query that retrieves the ID and displayName of some movies:
+
.Query to fetch movies from the Headless API:
[source,GraphQL]
----
{
    guillotine {
        query(query: "valid='true' and type='com.example.myproject:movie'", sort: "displayName") {
            id: _id
            displayName
        }
    }
}
----
+
. **View the Result**
+
After executing the query, you should get a result in the right panel.
image:graphql-query.png[title="Running a query for movies in the GraphQL playground", width=1440px]

== Task: Query variables

In addition to the query itself, GraphQL also supports optional `variables`.
Variables enable you to re-use the same query, but for instance fetch different content each time.

. **Add query** to the GraphQL playground:
+
[source,JavaScript]
----
query($path:ID!){               <!--1-->
  guillotine {
    get(key:$path) {            <!--2-->
      type
      _id
      displayName
    }
  }
}
----
<1> `path` is declared (with a `$` marking it as a variable in the query). The declaration includes its type (`ID`), and a `!` marking it as a _required_ parameter).
<2> The `path` variable here used as the value of the `key` parameter, passed to the `get` field.
+
. **Add query Variables** using the tab at the bottom to add a `variables` JSON object. Notice how the `path` field corresponds to the `$path` in the query string.:
+
[source,JSON]
----
{
    "path": "${site}/movies/se7en"
}
----
+
NOTE: ${site} is a valid path element in Guillotine paths, and will internally resolve the path of the site and expand it - in this case the full path will be expanded to `/hmdb/movies/se7en`.
+
. **Run the query** with the variables, and see the result.

== Task: type introspection

The queries above only specify fields like `_id` and `displayName` for each content found. These are general fields in the CMS, available across all content types.

Content types may also define their own link:https://developer.enonic.com/docs/xp/stable/cms/content-types[custom fields]. These are stored under the `data` field. In the headless API, deeper data and functionality belonging to a content type is accessed through **introspection**.

For example, you may introspect the fields that are exclusive to the `com.example.myproject:movie` content type like this:

.Content type introspection:
[source,options="nowrap"]
----
... on com_example_myproject_Movie
----
NOTE: The fully-qualified content type name is used, dots are replaced with underscores, and the name is capitalized `Movie`.

. **Fetch a complex data set**
+
Lets get content for a movie, the referenced _image_ items `media:image` and _person_ items `com.example.myproject:person` in a single query:
+
Copy this query into the GraphQL playground...
+
.A query with nested introspections
[source,JavaScript]
----
query($path:ID!){
  guillotine {
    get(key:$path) {
      type
      displayName
      ... on com_example_myproject_Movie {
        data {
          subtitle
          abstract
          trailer
          release
          photos {
            ... on media_Image {
                imageUrl: imageUrl(type: absolute, scale: "width(500)")
            }
          }
          cast {
            character
            actor {
              displayName
              ... on com_example_myproject_Person {
                _path
                data {
                  photos {
                    ... on media_Image {
                      imageUrl: imageUrl(type: absolute, scale: "block(100,100)")
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
----
<1> See how `imageUrl` is requested with parameters of its own? Type introspections can expose certain link:https://developer.enonic.com/docs/guillotine/stable/api[functions for processing data] before returning it.
+
Since the query is still parameterized with `$path`, we can use the same `variables` object used earlier
+
.Variables
[source,JSON]
----
{
    "path": "${site}/movies/pulp-fiction"
}
----
+
Run the query in the playground. It should produce a fully resolved set of data - which will come in handy later in this tutorial.
+
All in all, this allows for fetching deep and rich content data in a single API request.

**Congrats on setting up the Enonic SDK environment**

Coming up - get up and running with <<next-setup#, your Next.js developer environment>>.